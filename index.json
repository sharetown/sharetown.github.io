[{"content":"博主的社会阅历太少且没什么看点，履历暂无或不愿公布，暂无法查看\n","date":"29 October 2022","permalink":"/about/","section":"SharetownBlog","summary":"博主的社会阅历太少且没什么看点，履历暂无或不愿公布，暂无法查看","title":"关于我"},{"content":"","date":"26 October 2022","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"26 October 2022","permalink":"/tags/echats/","section":"Tags","summary":"","title":"EChats"},{"content":"Echats插件的使用 # 一、什么是Echats？ # ECharts 是一个使用 JavaScript 实现的开源可视化库，涵盖各行业图表，满足各种需求。\nECharts 遵循 Apache-2.0 开源协议，免费商用。\nECharts 兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等）及兼容多种设备，可随时随地任性展示。\n二、Echats配置语法 # 第一步：创建HTML页面 # 创建一个HTMl页面，引入Echats的js文件\n引入Echats文件有三种方法，分别是：\n下载Echats独立版本，然后在\u0026lt;script\u0026gt;标签中引入echarts.min.js即可。echarts.min.js文件下载地址：https://github.com/apache/incubator-echarts/tree/4.8.0/dist使用Git下载\n使用CDN方法： Staticfile CDN（国内） : https://cdn.staticfile.org/echarts/4.3.0/echarts.min.js 百度：https://echarts.baidu.com/dist/echarts.min.js, 保持了最新版本。 cdnjs : https://cdnjs.cloudflare.com/ajax/libs/echarts/4.3.0/echarts.min.js 使用方法：以Staticfile CDN为例：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;第一个 ECharts 实例\u0026lt;/title\u0026gt; \u0026lt;!-- 引入 echarts.js --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.org/echarts/4.3.0/echarts.min.js\u0026#34;\u0026gt; \u0026lt;!-- 在head中引入js地址即可 --\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; NPM方法（不推荐） 第二步: 为 ECharts 准备一个具备高宽的 DOM 容器 # \u0026lt;body\u0026gt; \u0026lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --\u0026gt; \u0026lt;div id=\u0026#34;main\u0026#34; style=\u0026#34;width: 600px;height:400px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 第三步：设置配置信息 # Echats库使用json格式来配置\necharts.init(document.getElementById(\u0026#39;main\u0026#39;)).setOption(option); \u0026lt;!--这里 option 表示使用 json 数据格式的配置来绘制图表。步骤如下：--\u0026gt; \u0026lt;!--为图表配置标题--\u0026gt; title:{ text:\u0026#39;标题\u0026#39; } \u0026lt;!--配置提示信息--\u0026gt; tooltip: {}, \u0026lt;!--图例组件--\u0026gt; legend: { data: [{ name: \u0026#39;系列1\u0026#39;, // 强制设置图形为圆。 icon: \u0026#39;circle\u0026#39;, // 设置文本为红色 textStyle: { color: \u0026#39;red\u0026#39; } }] } \u0026lt;!--配置要在X轴显示的项--\u0026gt; xAxis: { data: [\u0026#34;衬衫\u0026#34;,\u0026#34;羊毛衫\u0026#34;,\u0026#34;雪纺衫\u0026#34;,\u0026#34;裤子\u0026#34;,\u0026#34;高跟鞋\u0026#34;,\u0026#34;袜子\u0026#34;] } \u0026lt;!--配置要在Y轴显示的项--\u0026gt; yAxis: {} \u0026lt;!--选择用什么类型的图表来显示数据,在Echats中图表类型称为系列--\u0026gt; series: [{ name: \u0026#39;销量\u0026#39;, // 系列名称 type: \u0026#39;bar\u0026#39;, // 系列图表类型 data: [5, 20, 36, 10, 10, 20] // 系列中的数据内容 }] 附：每个系列的表示方法\n图表类型 系列表示法 图表类型 系列表示法 柱状/条形图 type:'bar' 折线/面积图 type:'line' 饼图 type:'pie' 散点（气泡）图 type:'scatter' 带有涟漪特效动画的散点（气泡） type:'effectScatter' 雷达图 type: 'radar' 树型图 type: 'tree' 树型图 type: 'treemap' 旭日图 type: 'sunburst' 箱形图 type: 'boxplot' K线图 type: 'candlestick' 热力图 type: 'heatmap' 地图 type: 'map' 平行坐标系的系列 type: 'parallel' 线图 type: 'lines' 关系图 type: 'graph' 桑基图 type: 'sankey' 漏斗图 type: 'funnel' 仪表盘` type: 'gauge' 象形柱图 type: 'pictorialBar' 主题河流 type: 'themeRiver' 自定义系列 type: 'custom' 示例：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;我的第一个Echats实例\u0026lt;/title\u0026gt; \u0026lt;!-- 引入 echarts.js --\u0026gt; \u0026lt;script src=\u0026#34;js/echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --\u0026gt; \u0026lt;div id=\u0026#34;main\u0026#34; style=\u0026#34;width: 600px;height:400px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById(\u0026#39;main\u0026#39;)); // 指定图表的配置项和数据 var option = { title: { text: \u0026#39;第一个 ECharts 实例\u0026#39; }, tooltip: {}, legend: { data:[\u0026#39;销量\u0026#39;] }, xAxis: { data: [\u0026#34;衬衫\u0026#34;,\u0026#34;羊毛衫\u0026#34;,\u0026#34;雪纺衫\u0026#34;,\u0026#34;裤子\u0026#34;,\u0026#34;高跟鞋\u0026#34;,\u0026#34;袜子\u0026#34;] }, yAxis: {}, series: [{ name: \u0026#39;销量\u0026#39;, type: \u0026#39;bar\u0026#39;, data: [5, 20, 36, 10, 10, 20] }] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 三、饼图 # 前面的章节我们已经学会了使用 ECharts 绘制一个简单的柱状图，本章节我们将绘制饼图。\n饼图主要是通过扇形的弧度表现不同类目的数据在总和中的占比，它的数据格式比柱状图更简单，只有一维的数值，不需要给类目。因为不在直角坐标系上，所以也不需要 xAxis，yAxis。\n实例：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;饼图\u0026lt;/title\u0026gt; \u0026lt;!-- 引入 echarts.js --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.org/echarts/4.3.0/echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --\u0026gt; \u0026lt;div id=\u0026#34;main\u0026#34; style=\u0026#34;width: 600px;height:400px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById(\u0026#39;main\u0026#39;)); myChart.setOption({ title:{ text:\u0026#39;饼图\u0026#39; }, tooltip: {}, legend: { data:[\u0026#39;视频广告\u0026#39;,\u0026#39;联盟广告\u0026#39;,\u0026#39;邮件营销\u0026#39;,\u0026#39;直接访问\u0026#39;,\u0026#39;搜索引擎\u0026#39;] }, series : [ { name: \u0026#39;访问来源\u0026#39;, type: \u0026#39;pie\u0026#39;, // 设置图表类型为饼图 radius: \u0026#39;55%\u0026#39;, // 饼图的半径，外半径为可视区尺寸（容器高宽中较小一项）的 55% 长度。 data:[ // 数据数组，name 为数据项名称，value 为数据项值 {value:235, name:\u0026#39;视频广告\u0026#39;}, {value:274, name:\u0026#39;联盟广告\u0026#39;}, {value:310, name:\u0026#39;邮件营销\u0026#39;}, {value:335, name:\u0026#39;直接访问\u0026#39;}, {value:400, name:\u0026#39;搜索引擎\u0026#39;} ] } ] }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; roseType: 'angle'属性 # 我们也可以通过设置参数 roseType: \u0026lsquo;angle\u0026rsquo; 把饼图显示成南丁格尔图\nseries : [ { name: \u0026#39;访问来源\u0026#39;, type: \u0026#39;pie\u0026#39;, // 设置图表类型为饼图 radius: \u0026#39;55%\u0026#39;, // 饼图的半径，外半径为可视区尺寸（容器高宽中较小一项）的 55% 长度。 roseType: \u0026#39;angle\u0026#39;,//把饼图显示成南丁格尔图 data:[ // 数据数组，name 为数据项名称，value 为数据项值 {value:235, name:\u0026#39;视频广告\u0026#39;}, {value:274, name:\u0026#39;联盟广告\u0026#39;}, {value:310, name:\u0026#39;邮件营销\u0026#39;}, {value:335, name:\u0026#39;直接访问\u0026#39;}, {value:400, name:\u0026#39;搜索引擎\u0026#39;} ] } ] 阴影的配置 # itemStyle 参数可以设置诸如阴影、透明度、颜色、边框颜色、边框宽度等：\nitemStyle: { normal: { shadowBlur: 200, shadowColor: \u0026#39;rgba(0, 0, 0, 0.5)\u0026#39; } } //以上属性都是嵌入到series中 高亮样式配置：emphasis # // 高亮样式。 emphasis: { itemStyle: { // 高亮时点的颜色 color: \u0026#39;red\u0026#39; }, label: { show: true, // 高亮时标签的文字 formatter: \u0026#39;高亮时显示的标签内容\u0026#39; } }, //以上属性都是嵌入到series中 四、Echats异步加载数据 # ECharts 通常数据设置在 setOption 中，如果我们需要异步加载数据，可以配合 jQuery等工具，在异步获取数据后通过 setOption 填入数据和配置项就行。\nECharts 通常数据设置在 setOption 中，如果我们需要异步加载数据，可以配合 jQuery等工具，在异步获取数据后通过 setOption 填入数据和配置项就行。 json 数据：\n数据的动态更新 # ECharts 由数据驱动，数据的改变驱动图表展现的改变，因此动态数据的实现也变得异常简单。\n所有数据的更新都通过 setOption 实现，你只需要定时获取数据，setOption 填入数据，而不用考虑数据到底产生了那些变化，ECharts 会找到两组数据之间的差异然后通过合适的动画去表现数据的变化。\n五、Echats数据集 # ECharts 使用 dataset 管理数据。\ndataset 组件用于单独的数据集声明，从而数据可以单独管理，被多个组件复用，并且可以基于数据指定数据到视觉的映射。\n下面是一个最简单的 dataset 的例子：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;第一个 ECharts 实例\u0026lt;/title\u0026gt; \u0026lt;!-- 引入 echarts.js --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.org/echarts/4.3.0/echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --\u0026gt; \u0026lt;div id=\u0026#34;main\u0026#34; style=\u0026#34;width: 600px;height:400px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById(\u0026#39;main\u0026#39;)); // 指定图表的配置项和数据 var option = { legend: {}, tooltip: {}, dataset: { // 提供一份数据。 source: [ [\u0026#39;product\u0026#39;, \u0026#39;2015\u0026#39;, \u0026#39;2016\u0026#39;, \u0026#39;2017\u0026#39;], [\u0026#39;Matcha Latte\u0026#39;, 43.3, 85.8, 93.7], [\u0026#39;Milk Tea\u0026#39;, 83.1, 73.4, 55.1], [\u0026#39;Cheese Cocoa\u0026#39;, 86.4, 65.2, 82.5], [\u0026#39;Walnut Brownie\u0026#39;, 72.4, 53.9, 39.1] ] }, // 声明一个 X 轴，类目轴（category）。默认情况下，类目轴对应到 dataset 第一列。 xAxis: {type: \u0026#39;category\u0026#39;}, // 声明一个 Y 轴，数值轴。 yAxis: {}, // 声明多个 bar 系列，默认情况下，每个系列会自动对应到 dataset 的每一列。 series: [ {type: \u0026#39;bar\u0026#39;}, {type: \u0026#39;bar\u0026#39;}, {type: \u0026#39;bar\u0026#39;} ] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 或者也可以使用常见的对象数组的格式：\ndataset: { source: [ [\u0026#39;product\u0026#39;, \u0026#39;2012\u0026#39;, \u0026#39;2013\u0026#39;, \u0026#39;2014\u0026#39;, \u0026#39;2015\u0026#39;], [\u0026#39;Matcha Latte\u0026#39;, 41.1, 30.4, 65.1, 53.3], [\u0026#39;Milk Tea\u0026#39;, 86.5, 92.1, 85.7, 83.1], [\u0026#39;Cheese Cocoa\u0026#39;, 24.1, 67.2, 79.5, 86.4] ] }, 数据到图形的映射 # 我们可以在配置项中将数据映射到图形中。\n我么可以使用 series.seriesLayoutBy 属性来配置 dataset 是列（column）还是行（row）映射为图形系列（series），默认是按照列（column）来映射。\n以下实例我们将通过 seriesLayoutBy 属性来配置数据是使用列显示还是按行显示。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;第一个 ECharts 实例\u0026lt;/title\u0026gt; \u0026lt;!-- 引入 echarts.js --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.org/echarts/4.3.0/echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --\u0026gt; \u0026lt;div id=\u0026#34;main\u0026#34; style=\u0026#34;width: 600px;height:400px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById(\u0026#39;main\u0026#39;)); // 指定图表的配置项和数据 var option = { legend: {}, tooltip: {}, dataset: { source: [ [\u0026#39;product\u0026#39;, \u0026#39;2012\u0026#39;, \u0026#39;2013\u0026#39;, \u0026#39;2014\u0026#39;, \u0026#39;2015\u0026#39;], [\u0026#39;Matcha Latte\u0026#39;, 41.1, 30.4, 65.1, 53.3], [\u0026#39;Milk Tea\u0026#39;, 86.5, 92.1, 85.7, 83.1], [\u0026#39;Cheese Cocoa\u0026#39;, 24.1, 67.2, 79.5, 86.4] ] }, xAxis: [ {type: \u0026#39;category\u0026#39;, gridIndex: 0}, {type: \u0026#39;category\u0026#39;, gridIndex: 1} ], yAxis: [ {gridIndex: 0}, {gridIndex: 1} ], grid: [ {bottom: \u0026#39;55%\u0026#39;}, {top: \u0026#39;55%\u0026#39;} ], series: [ // 这几个系列会在第一个直角坐标系中，每个系列对应到 dataset 的每一行。 {type: \u0026#39;bar\u0026#39;, seriesLayoutBy: \u0026#39;row\u0026#39;}, {type: \u0026#39;bar\u0026#39;, seriesLayoutBy: \u0026#39;row\u0026#39;}, {type: \u0026#39;bar\u0026#39;, seriesLayoutBy: \u0026#39;row\u0026#39;}, // 这几个系列会在第二个直角坐标系中，每个系列对应到 dataset 的每一列。 {type: \u0026#39;bar\u0026#39;, xAxisIndex: 1, yAxisIndex: 1}, {type: \u0026#39;bar\u0026#39;, xAxisIndex: 1, yAxisIndex: 1}, {type: \u0026#39;bar\u0026#39;, xAxisIndex: 1, yAxisIndex: 1}, {type: \u0026#39;bar\u0026#39;, xAxisIndex: 1, yAxisIndex: 1} ] } // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 常用图表所描述的数据大部分是\u0026quot;二维表\u0026quot;结构，我们可以使用 series.encode 属性将对应的数据映射到坐标轴（如 X、Y 轴）：\nseries: [ { type: \u0026#39;bar\u0026#39;, encode: { // 将 \u0026#34;amount\u0026#34; 列映射到 X 轴。 x: \u0026#39;amount\u0026#39;, // 将 \u0026#34;product\u0026#34; 列映射到 Y 轴。 y: \u0026#39;product\u0026#39; } } ] encode 声明的基本结构如下，其中冒号左边是坐标系、标签等特定名称，如 \u0026lsquo;x\u0026rsquo;, \u0026lsquo;y\u0026rsquo;, \u0026rsquo;tooltip\u0026rsquo; 等，冒号右边是数据中的维度名（string 格式）或者维度的序号（number 格式，从 0 开始计数），可以指定一个或多个维度（使用数组）。通常情况下，下面各种信息不需要所有的都写，按需写即可。\n下面是 encode 支持的属性：\n// 在任何坐标系和系列中，都支持： encode: { // 使用 “名为 product 的维度” 和 “名为 score 的维度” 的值在 tooltip 中显示 tooltip: [\u0026#39;product\u0026#39;, \u0026#39;score\u0026#39;] // 使用 “维度 1” 和 “维度 3” 的维度名连起来作为系列名。（有时候名字比较长，这可以避免在 series.name 重复输入这些名字） seriesName: [1, 3], // 表示使用 “维度2” 中的值作为 id。这在使用 setOption 动态更新数据时有用处，可以使新老数据用 id 对应起来，从而能够产生合适的数据更新动画。 itemId: 2, // 指定数据项的名称使用 “维度3” 在饼图等图表中有用，可以使这个名字显示在图例（legend）中。 itemName: 3 } // 直角坐标系（grid/cartesian）特有的属性： encode: { // 把 “维度1”、“维度5”、“名为 score 的维度” 映射到 X 轴： x: [1, 5, \u0026#39;score\u0026#39;], // 把“维度0”映射到 Y 轴。 y: 0 } // 单轴（singleAxis）特有的属性： encode: { single: 3 } // 极坐标系（polar）特有的属性： encode: { radius: 3, angle: 2 } // 地理坐标系（geo）特有的属性： encode: { lng: 3, lat: 2 } // 对于一些没有坐标系的图表，例如饼图、漏斗图等，可以是： encode: { value: 3 } 视觉通道（颜色、尺寸等）的映射 # 我们可以使用 visualMap 组件进行视觉通道的映射。\n视觉元素可以是：\nsymbol: 图元的图形类别。\nsymbolSize: 图元的大小。\ncolor: 图元的颜色。\ncolorAlpha: 图元的颜色的透明度。\nopacity: 图元以及其附属物（如文字标签）的透明度。\ncolorLightness: 颜色的明暗度。\ncolorSaturation: 颜色的饱和度。\ncolorHue: 颜色的色调。\nvisualMap 组件可以定义多个，从而可以同时对数据中的多个维度进行视觉映射。\nvisualMap: { orient: \u0026#39;horizontal\u0026#39;, left: \u0026#39;center\u0026#39;, min: 10, max: 100, text: [\u0026#39;High Score\u0026#39;, \u0026#39;Low Score\u0026#39;], // Map the score column to color dimension: 0, inRange: { color: [\u0026#39;#D7DA8B\u0026#39;, \u0026#39;#E15457\u0026#39;] } }, 交互联动 # 以下实例多个图表共享一个 dataset，并带有联动交互：\n以下代码暂时看不懂\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;ECharts 实例\u0026lt;/title\u0026gt; \u0026lt;!-- 引入 echarts.js --\u0026gt; \u0026lt;script src=\u0026#34;js/echarts.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --\u0026gt; \u0026lt;div id=\u0026#34;main\u0026#34; style=\u0026#34;width: 600px;height:400px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById(\u0026#39;main\u0026#39;)); setTimeout(function () { option = { legend: {}, tooltip: { trigger: \u0026#39;axis\u0026#39;, showContent: false }, dataset: { source: [ [\u0026#39;product\u0026#39;, \u0026#39;2012\u0026#39;, \u0026#39;2013\u0026#39;, \u0026#39;2014\u0026#39;, \u0026#39;2015\u0026#39;, \u0026#39;2016\u0026#39;, \u0026#39;2017\u0026#39;], [\u0026#39;Matcha Latte\u0026#39;, 41.1, 30.4, 65.1, 53.3, 83.8, 98.7], [\u0026#39;Milk Tea\u0026#39;, 86.5, 92.1, 85.7, 83.1, 73.4, 55.1], [\u0026#39;Cheese Cocoa\u0026#39;, 24.1, 67.2, 79.5, 86.4, 65.2, 82.5], [\u0026#39;Walnut Brownie\u0026#39;, 55.2, 67.1, 69.2, 72.4, 53.9, 39.1] ] }, xAxis: {type: \u0026#39;category\u0026#39;}, yAxis: {gridIndex: 0}, grid: {top: \u0026#39;55%\u0026#39;}, series: [ {type: \u0026#39;line\u0026#39;, smooth: true, seriesLayoutBy: \u0026#39;row\u0026#39;}, {type: \u0026#39;line\u0026#39;, smooth: true, seriesLayoutBy: \u0026#39;row\u0026#39;}, {type: \u0026#39;line\u0026#39;, smooth: true, seriesLayoutBy: \u0026#39;row\u0026#39;}, {type: \u0026#39;line\u0026#39;, smooth: true, seriesLayoutBy: \u0026#39;row\u0026#39;}, { type: \u0026#39;pie\u0026#39;, id: \u0026#39;pie\u0026#39;, radius: \u0026#39;30%\u0026#39;, center: [\u0026#39;50%\u0026#39;, \u0026#39;25%\u0026#39;], label: { formatter: \u0026#39;{b}: {@2012} ({d}%)\u0026#39; }, encode: { itemName: \u0026#39;product\u0026#39;, value: \u0026#39;2012\u0026#39;, tooltip: \u0026#39;2012\u0026#39; } } ] }; myChart.on(\u0026#39;updateAxisPointer\u0026#39;, function (event) { var xAxisInfo = event.axesInfo[0]; if (xAxisInfo) { var dimension = xAxisInfo.value + 1; myChart.setOption({ series: { id: \u0026#39;pie\u0026#39;, label: { formatter: \u0026#39;{b}: {@[\u0026#39; + dimension + \u0026#39;]} ({d}%)\u0026#39; }, encode: { value: dimension, tooltip: dimension } } }); } }); myChart.setOption(option); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 六、Echats交互组件 # ECharts 提供了很多交互组件：例组件 legend、标题组件 title、视觉映射组件 visualMap、数据区域缩放组件 dataZoom、时间线组件 timeline。\n接下来的内容我们将介绍如何使用数据区域缩放组件 dataZoom。\ndataZoom # dataZoom 组件可以实现通过鼠标滚轮滚动，放大缩小图表的功能。\n默认情况下 dataZoom 控制 x 轴，即对 x 轴进行数据窗口缩放和数据窗口平移操作。\ndataZoom: [ { // 这个dataZoom组件，默认控制x轴。 type: \u0026#39;slider\u0026#39;, // 这个 dataZoom 组件是 slider 型 dataZoom 组件 start: 10, // 左边在 10% 的位置。 end: 60 // 右边在 60% 的位置。 } ], 上面的实例只能拖动 dataZoom 组件来缩小或放大图表。如果想在坐标系内进行拖动，以及用鼠标滚轮（或移动触屏上的两指滑动）进行缩放，那么需要 再再加上一个 inside 型的 dataZoom 组件。\n在以上实例基础上我们再增加type: 'inside'的配置信息：\ndataZoom: [ { // 这个dataZoom组件，默认控制x轴。 type: \u0026#39;slider\u0026#39;, // 这个 dataZoom 组件是 slider 型 dataZoom 组件 start: 10, // 左边在 10% 的位置。 end: 60 // 右边在 60% 的位置。 }, { // 这个dataZoom组件，也控制x轴。 type: \u0026#39;inside\u0026#39;, // 这个 dataZoom 组件是 inside 型 dataZoom 组件 start: 10, // 左边在 10% 的位置。 end: 60 // 右边在 60% 的位置。 } ], 当然我们可以通过 dataZoom.xAxisIndex 或 dataZoom.yAxisIndex 来指定 dataZoom 控制哪个或哪些数轴。\ndataZoom: [ { type: \u0026#39;slider\u0026#39;, show: true, xAxisIndex: [0], start: 1, end: 35 }, { type: \u0026#39;slider\u0026#39;, show: true, yAxisIndex: [0], left: \u0026#39;93%\u0026#39;, start: 29, end: 36 }, { type: \u0026#39;inside\u0026#39;, xAxisIndex: [0], start: 1, end: 35 }, { type: \u0026#39;inside\u0026#39;, yAxisIndex: [0], start: 29, end: 36 } ], 七、Echats响应式 # ECharts 图表显示在用户指定高宽的 DOM 节点（容器）中。\n有时候我们希望在 PC 和 移动设备上都能够很好的展示图表的内容，实现响应式的设计，为了解决这个问题，ECharts 完善了组件的定位设置，并且实现了类似 CSS Media Query 的自适应能力。\nEchats组件的定位和布局 # 大部分『组件』和『系列』会遵循两种定位方式。\nleft/right/top/bottom/width/height 定位方式\n这六个量中，每个量都可以是『绝对值』或者『百分比』或者『位置描述』。\n绝对值\n单位是浏览器像素（px），用 number 形式书写（不写单位）。例如 {left: 23, height: 400}。\n百分比\n表示占 DOM 容器高宽的百分之多少，用 string 形式书写。例如 {right: \u0026lsquo;30%\u0026rsquo;, bottom: \u0026lsquo;40%\u0026rsquo;}。\n位置描述\n可以设置 left: \u0026lsquo;center\u0026rsquo;，表示水平居中。 可以设置 top: \u0026lsquo;middle\u0026rsquo;，表示垂直居中。\n这六个量的概念，和 CSS 中六个量的概念类似：\nleft：距离 DOM 容器左边界的距离。\nright：距离 DOM 容器右边界的距离。\ntop：距离 DOM 容器上边界的距离。\nbottom：距离 DOM 容器下边界的距离。\nwidth：宽度。\nheight：高度。\n在横向，left、right、width 三个量中，只需两个量有值即可，因为任两个量可以决定组件的位置和大小，例如 left 和 right 或者 right 和 width 都可以决定组件的位置和大小。 纵向，top、bottom、height 三个量，和横向类同不赘述。\ncenter / radius 定位方式\ncenter\n是一个数组，表示 [x, y]，其中，x、y可以是『绝对值』或者『百分比』，含义和前述相同。\nradius\n是一个数组，表示 [内半径, 外半径]，其中，内外半径可以是『绝对值』或者『百分比』，含义和前述相同。\n在自适应容器大小时，百分比设置是很有用的。\n横向（horizontal）和纵向（vertical） # ECharts的『外观狭长』型的组件（如 legend、visualMap、dataZoom、timeline等），大多提供了『横向布局』『纵向布局』的选择。例如，在细长的移动端屏幕上，可能适合使用『纵向布局』；在PC宽屏上，可能适合使用『横向布局』。\n横纵向布局的设置，一般在『组件』或者『系列』的 orient 或者 layout 配置项上，设置为 \u0026lsquo;horizontal\u0026rsquo; 或者 \u0026lsquo;vertical\u0026rsquo;。\n","date":"26 October 2022","permalink":"/posts/echats%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/","section":"Posts","summary":"Echats插件的使用 # 一、什么是Echats？ # ECharts 是一个使用 JavaScript 实现的开源可视化库，涵盖各行业图表，满足各种需求。\nECharts 遵循 Apache-2.0 开源协议，免费商用。\nECharts 兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等）及兼容多种设备，可随时随地任性展示。\n二、Echats配置语法 # 第一步：创建HTML页面 # 创建一个HTMl页面，引入Echats的js文件\n引入Echats文件有三种方法，分别是：\n下载Echats独立版本，然后在\u0026lt;script\u0026gt;标签中引入echarts.min.js即可。echarts.min.js文件下载地址：https://github.com/apache/incubator-echarts/tree/4.8.0/dist使用Git下载\n使用CDN方法： Staticfile CDN（国内） : https://cdn.staticfile.org/echarts/4.3.0/echarts.min.js 百度：https://echarts.baidu.com/dist/echarts.min.js, 保持了最新版本。 cdnjs : https://cdnjs.","title":"EChats组件的使用"},{"content":"","date":"26 October 2022","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"26 October 2022","permalink":"/","section":"SharetownBlog","summary":"","title":"SharetownBlog"},{"content":"","date":"26 October 2022","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"26 October 2022","permalink":"/tags/%E5%89%8D%E7%AB%AF/","section":"Tags","summary":"","title":"前端"},{"content":"","date":"26 October 2022","permalink":"/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/","section":"Categories","summary":"","title":"数据可视化"},{"content":"","date":"26 October 2022","permalink":"/categories/python/","section":"Categories","summary":"","title":"python"},{"content":"","date":"26 October 2022","permalink":"/tags/%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/","section":"Tags","summary":"","title":"非线性回归"},{"content":"","date":"26 October 2022","permalink":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","section":"Tags","summary":"","title":"机器学习"},{"content":"","date":"26 October 2022","permalink":"/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/","section":"Tags","summary":"","title":"线性回归"},{"content":" 线性还是非线性是要根据分析的目标来决定的，在线性回归和非线性回归中，我们需要求解的是模型参数，因而，线性与非线性描述的是函数模型与模型参数之间的关系，而非因变量与自变量之间的关系\n代价函数（损失函数）（Cost function） # 最小二乘法 真实值$y$,预测值$h_\\theta$,则误差平方为$(y-h_\\theta(x))^2$. 找到合适的参数，使得误差平方和： $$ 对于线性的： h_\\theta(x)=\\theta_0+\\theta_1x J(\\theta_0,\\theta_1)=\\dfrac{1}{2m}\\textstyle\\sum_{i=1}^m(y^i-h_\\theta(x^j))^2 $$ 最小\n我们使用相关系数去衡量线性相关的强弱： $$ r_{xy}=\\dfrac{\\sum(X_i-\\overline{X})(Y_i-\\overline{Y})}{\\sqrt{\\sum(X_i-\\overline{X})^2\\sum(Y_i-\\overline{Y})^2}} $$ 其中$X_i$表示真实值的横坐标；$Y_i$表示真实值纵横坐标；$\\overline{X}$表示真实值的横坐标的平均值；$\\overline{Y}$表示真实值的纵坐标的平均值。 相关系数$R^2$是用来描述两个变量之间的线性关系的，但决定系数的适用范围更广, 可以用于描述非线性或者有个及两个以上自变量的相关关系。它可以用来评价模型的效果。 总平方和（SST）：$\\textstyle\\sum_{i=1}^n(y_i-\\overline{y})^2$ 回归平方和（SSR）：$\\textstyle\\sum_{i=1}^n(\\hat{y}-\\overline{y})^2$ 残差平方和（SSE）：$\\textstyle\\sum_{i=1}^n(y_i-\\hat{y})^2$ 它们三者的关系是：$SST=SSR+SSE$ 决定系数：$R^2=\\dfrac{SSR}{SST}=1-\\dfrac{SSE}{SST}$ 一、梯度下降 # 需要做一个迭代： $$ \\theta_j:=\\theta_j-\\alpha\\dfrac{\\partial}{\\partial\\theta_j}J(\\theta_0,\\theta_1),j=0,1 $$ 其中$\\alpha$为学习率;$:=$为赋值符，将右边赋值给左边\n这个迭代公式在更新的时候必须同步更新，即： $$ temp0:=\\theta_0-\\alpha\\dfrac{\\partial}{\\partial\\theta_0}J(\\theta_0,\\theta_1)\ntemp1:=\\theta_1-\\alpha\\dfrac{\\partial}{\\partial\\theta_1}J(\\theta_0,\\theta_1)\n\\theta_0:=temp0\n\\theta_1:=temp1 $$ 学习率不能太小也不能太大。太小计算耗时，太大就会发生震荡。\n1、用梯度下降法来求解线性回归 # 上面提到的$\\alpha\\dfrac{\\partial}{\\partial\\theta_j}J(\\theta_0,\\theta_1)$`拆开来是这样的： $$ j=0:\\alpha\\dfrac{\\partial}{\\partial\\theta_j}J(\\theta_0,\\theta_1)=\\dfrac{1}{m}\\displaystyle\\sum_{i=1}^m(h_\\theta(x^{(i)})-y^{(i)}) $$ $$ j=1:\\alpha\\dfrac{\\partial}{\\partial\\theta_j}J(\\theta_0,\\theta_1)=\\dfrac{1}{m}\\displaystyle\\sum_{i=1}^m(h_\\theta(x^{(i)})-y^{(i)})\\cdotp x^{(i)} $$ 需要注意的是用梯度下降法来求解线性回归，如果函数是凸函数那么最终可以求得全局最优解，但如果函数是非凸函数，那么求得的解就有可能陷入局部最优。\n实战1.1 一元线性回归 # 语言：Python\n一、使用numpy实现**：**\n第三方库**：numpy、matplotlib。\nimport numpy as np import matplotlib.pyplot as plt #----------------------上面是导包 # 载入数据 data = np.genfromtxt(\u0026#34;data.csv\u0026#34;, delimiter=\u0026#34;,\u0026#34;) # 注意data.csv的路径 x_data = data[:,0] y_data = data[:,1] plt.scatter(x_data,y_data) plt.show() #-----------------------上面是载入数据后给原始数据利用matplotlib画出原始数据的散点图 # 学习率learning rate lr = 0.0001 # 截距 b = 0 # 斜率 k = 0 # 最大迭代次数 epochs = 50 #------------------------上面这段初始化学习率、截距、斜率和最大迭代次数 # 最小二乘法 def compute_error(b, k, x_data, y_data): totalError = 0 for i in range(0, len(x_data)): totalError += (y_data[i] - (k * x_data[i] + b)) ** 2 return totalError / float(len(x_data)) / 2.0 #--------------------------上面这段是利用最小二乘法求误差平方和 def gradient_descent_runner(x_data, y_data, b, k, lr, epochs):#这个函数就是利用梯度下降迭代来更新斜率和截距 # 计算总数据量 m = float(len(x_data)) # 循环epochs次 for i in range(epochs): b_grad = 0#临时截距 k_grad = 0#临时斜率 # 计算梯度的总和再求平均 for j in range(0, len(x_data)): b_grad += (1/m) * (((k * x_data[j]) + b) - y_data[j]) k_grad += (1/m) * x_data[j] * (((k * x_data[j]) + b) - y_data[j]) # 更新b和k b = b - (lr * b_grad) k = k - (lr * k_grad) #---------------------完全按照梯度下降的公式实现的。 # 每迭代5次，输出一次图像 # if i % 5==0: # print(\u0026#34;epochs:\u0026#34;,i) # plt.plot(x_data, y_data, \u0026#39;b.\u0026#39;) # plt.plot(x_data, k*x_data + b, \u0026#39;r\u0026#39;) # plt.show() #被注释这一段可以每五次输出一张迭代后的图，可以很直观的看到对比。 return b, k print(\u0026#34;Starting b = {0}, k = {1}, error = {2}\u0026#34;.format(b, k, compute_error(b, k, x_data, y_data))) print(\u0026#34;Running...\u0026#34;) b, k = gradient_descent_runner(x_data, y_data, b, k, lr, epochs) print(\u0026#34;After {0} iterations b = {1}, k = {2}, error = {3}\u0026#34;.format(epochs, b, k, compute_error(b, k, x_data, y_data))) #画图 plt.plot(x_data, y_data, \u0026#39;b.\u0026#39;) plt.plot(x_data, k*x_data + b, \u0026#39;r\u0026#39;) plt.show() #-----------------最后这一段就是一个结果的输出 实战1.2 直接用sklearn库实现：（记住这个） # 第三方库：numpy、matplotlib、sklearn。\nfrom sklearn.linear_model import LinearRegression#导入sklearn中处理线性回归的包LinearRegression import numpy as np import matplotlib.pyplot as plt #----------------------导包 # 载入数据 data = np.genfromtxt(\u0026#34;data.csv\u0026#34;, delimiter=\u0026#34;,\u0026#34;) x_data = data[:,0] y_data = data[:,1] plt.scatter(x_data,y_data) plt.show() print(x_data.shape) #----------------------导入数据并画出原始数据的散点图 x_data = data[:,0,np.newaxis]#将数据的0列的元素切片出来，并利用np.newaxis这个参数使其具有维度。 y_data = data[:,1,np.newaxis] # 创建并拟合模型 model = LinearRegression()#创建LinearRegression类的对象model model.fit(x_data, y_data)#model对象调用fit函数，将两列元素传进去，由已经封装好的函数进行计算 #--------------------------用sklearn的LinearRegression进行建模 # 画图 plt.plot(x_data, y_data, \u0026#39;b.\u0026#39;) plt.plot(x_data, model.predict(x_data), \u0026#39;r\u0026#39;) plt.show() #-------------------------只画图 多元线性回归 # 当$y$的影响因素不是唯一时，采用多元线性回归模型。\n多特征 $$ h_\\theta(x)=\\theta_0+\\theta_1x_1+\\theta_2x_2+\\dots+\\theta_nx_n $$ 那么在这里的话有多少个特征就会有多少个x。\n多元线性回归的梯度下降 $$ \\theta_j:=\\theta_j-\\alpha\\dfrac{1}{m}\\displaystyle\\sum_{i=1}^m(h_\\theta(x^{(i)})-y^{(i)}) x_j^{(i)}\n(j=0,\\dots,n) $$\n2、梯度下降法解决多元线性回归 # 实战2.1：利用numpy使用梯度下降法\nimport numpy as np from numpy import genfromtxt import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D#画3D图的库 #----------------------------导库 data = genfromtxt(r\u0026#34;Delivery.csv\u0026#34;,delimiter=\u0026#39;,\u0026#39;) print(data) # 切分数据 x_data = data[:,:-1] y_data = data[:,-1] print(x_data) print(y_data) #-----------------------------导入数据 # 学习率learning rate lr = 0.0001 # 参数 theta0 = 0 theta1 = 0 theta2 = 0 # 最大迭代次数 epochs = 1000 # 最小二乘法 def compute_error(theta0, theta1, theta2, x_data, y_data): totalError = 0 for i in range(0, len(x_data)): totalError += (y_data[i] - (theta1 * x_data[i,0] + theta2*x_data[i,1] + theta0)) ** 2 return totalError / float(len(x_data)) #-----------------------------------求代价函数 def gradient_descent_runner(x_data, y_data, theta0, theta1, theta2, lr, epochs): # 计算总数据量 m = float(len(x_data)) # 循环epochs次 for i in range(epochs): theta0_grad = 0 theta1_grad = 0 theta2_grad = 0 # 计算梯度的总和再求平均 for j in range(0, len(x_data)): theta0_grad += (1/m) * ((theta1 * x_data[j,0] + theta2*x_data[j,1] + theta0) - y_data[j]) theta1_grad += (1/m) * x_data[j,0] * ((theta1 * x_data[j,0] + theta2*x_data[j,1] + theta0) - y_data[j]) theta2_grad += (1/m) * x_data[j,1] * ((theta1 * x_data[j,0] + theta2*x_data[j,1] + theta0) - y_data[j]) # 更新b和k theta0 = theta0 - (lr*theta0_grad) theta1 = theta1 - (lr*theta1_grad) theta2 = theta2 - (lr*theta2_grad) return theta0, theta1, theta2 #--------------------------------梯度下降法迭代更新参数 print(\u0026#34;Starting theta0 = {0}, theta1 = {1}, theta2 = {2}, error = {3}\u0026#34;. format(theta0, theta1, theta2, compute_error(theta0, theta1, theta2, x_data, y_data))) print(\u0026#34;Running...\u0026#34;) theta0, theta1, theta2 = gradient_descent_runner(x_data, y_data, theta0, theta1, theta2, lr, epochs) print(\u0026#34;After {0} iterations theta0 = {1}, theta1 = {2}, theta2 = {3}, error = {4}\u0026#34;. format(epochs, theta0, theta1, theta2, compute_error(theta0, theta1, theta2, x_data, y_data))) #------------------------------调用写的函数并输出结果 ax = plt.figure().add_subplot(111, projection = \u0026#39;3d\u0026#39;) ax.scatter(x_data[:,0], x_data[:,1], y_data, c = \u0026#39;r\u0026#39;, marker = \u0026#39;o\u0026#39;, s = 100) #点为红色三角形 x0 = x_data[:,0] x1 = x_data[:,1] # 生成网格矩阵 x0, x1 = np.meshgrid(x0, x1) z = theta0 + x0*theta1 + x1*theta2 # 画3D图 ax.plot_surface(x0, x1, z) #设置坐标轴 ax.set_xlabel(\u0026#39;Miles\u0026#39;) ax.set_ylabel(\u0026#39;Num of Deliveries\u0026#39;) ax.set_zlabel(\u0026#39;Time\u0026#39;) #显示图像 plt.show() #----------------------------画图，并且是画3D图 实战2.2：利用sklearn库实现多元线性回归（代码少）\nimport numpy as np from numpy import genfromtxt from sklearn import linear_model import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D #------------------------------导库 # 读入数据 data = genfromtxt(r\u0026#34;Delivery.csv\u0026#34;,delimiter=\u0026#39;,\u0026#39;) print(data) # 切分数据 x_data = data[:,:-1] y_data = data[:,-1] print(x_data) print(y_data) #-----------------------------导入数据 # 创建模型 model = linear_model.LinearRegression() model.fit(x_data, y_data) #----------------------------利用库建模 # 系数 print(\u0026#34;coefficients:\u0026#34;,model.coef_) # 截距 print(\u0026#34;intercept:\u0026#34;,model.intercept_) # 测试 x_test = [[102,4]] predict = model.predict(x_test) print(\u0026#34;predict:\u0026#34;,predict) #-------------------------------输出计算出的模型的参数并进行测试 ax = plt.figure().add_subplot(111, projection = \u0026#39;3d\u0026#39;) ax.scatter(x_data[:,0], x_data[:,1], y_data, c = \u0026#39;r\u0026#39;, marker = \u0026#39;o\u0026#39;, s = 100) #点为红色三角形 x0 = x_data[:,0] x1 = x_data[:,1] # 生成网格矩阵 x0, x1 = np.meshgrid(x0, x1) z = model.intercept_ + x0*model.coef_[0] + x1*model.coef_[1] # 画3D图 ax.plot_surface(x0, x1, z) #设置坐标轴 ax.set_xlabel(\u0026#39;Miles\u0026#39;) ax.set_ylabel(\u0026#39;Num of Deliveries\u0026#39;) ax.set_zlabel(\u0026#39;Time\u0026#39;) #显示图像 plt.show() #------------------------------画3D图 3、多项式回归 # 多项式回归，回归函数是回归变量多项式的回归。多项式回归模型是线性回归模型的一种，此时回归函数关于回归系数是线性的。由于任一函数都可以用多项式逼近，因此多项式回归有着广泛应用。 $$ y=\\theta_0+\\theta_1x+\\theta_2x+\\theta_3x+\\dots+\\theta_nx $$ 实战\nimport numpy as np import matplotlib.pyplot as plt from sklearn.preprocessing import PolynomialFeatures from sklearn.linear_model import LinearRegression #--------------------------导包 # 载入数据 data = np.genfromtxt(\u0026#34;job.csv\u0026#34;, delimiter=\u0026#34;,\u0026#34;) x_data = data[1:,1] y_data = data[1:,2] plt.scatter(x_data,y_data) plt.show() x_data = x_data[:,np.newaxis] y_data = y_data[:,np.newaxis] #---------------------------数据的导入 # 创建并拟合模型 model = LinearRegression() model.fit(x_data, y_data) #------------------------------先使用一元线性回归的模型来拟合 # 画图 plt.plot(x_data, y_data, \u0026#39;b.\u0026#39;) plt.plot(x_data, model.predict(x_data), \u0026#39;r\u0026#39;) plt.show() #-------------------------------画出使用一元线性回归来拟合多项式的结果 # 定义多项式回归,degree的值可以调节多项式的特征 poly_reg = PolynomialFeatures(degree=5) # 特征处理 x_poly = poly_reg.fit_transform(x_data) # 定义回归模型 lin_reg = LinearRegression() # 训练模型 lin_reg.fit(x_poly, y_data) #---------------------------------定义多项式回归并训练模型 # 画图 plt.plot(x_data, y_data, \u0026#39;b.\u0026#39;) plt.plot(x_data, lin_reg.predict(poly_reg.fit_transform(x_data)), c=\u0026#39;r\u0026#39;) plt.title(\u0026#39;Truth or Bluff (Polynomial Regression)\u0026#39;) plt.xlabel(\u0026#39;Position level\u0026#39;) plt.ylabel(\u0026#39;Salary\u0026#39;) plt.show() #--------------------------------画出使用多项式回归的结果图 二、标准方程法 # 标准方程法就是令式子的代价函数的偏导都等于0时所求得的解向量就是使代价函数最小的解。 $$ 令\\dfrac{\\partial}{\\partial\\theta_j}J(\\theta)=\\dots=0\n求解:\\theta_0,\\theta_1,\\dots,\\theta_n $$ 我们知道，在梯度下降法中，式子的代价函数为$J(\\theta_0,\\theta_1,\\dots,\\theta_n)=\\dfrac{1}{2m}\\textstyle\\sum_{i=1}^m(y^i-h_\\theta(x^j))^2$ 当我们有一组数据，我们把自变量用矩阵$X$表示，自变量用矩阵$y$表示，需要求解的令代价函数等于零的解用矩阵w表示。例如： $$ X=\\begin{bmatrix}x_{0,0}\u0026amp;x_{0,1}\u0026amp;x_{0,2}\u0026amp;x_{0,3}\u0026amp;x_{0,4}\\x_{1,0}\u0026amp;x_{1,1}\u0026amp;x_{1,2}\u0026amp;x_{1,3}\u0026amp;x_{1,4}\\x_{2,0}\u0026amp;x_{2,1}\u0026amp;x_{2,2}\u0026amp;x_{2,3}\u0026amp;x_{2,4}\\x_{3,0}\u0026amp;x_{3,1}\u0026amp;x_{3,2}\u0026amp;x_{3,3}\u0026amp;x_{3,4}\\end{bmatrix} w=\\begin{bmatrix}w_0\\w_1\\w_2\\w_3\\w_4 \\end{bmatrix} y=\\begin{bmatrix}y_0\\y_1\\y_2\\y_3\\y_4 \\end{bmatrix}\n\\displaystyle\\sum_{i=1}^m(h_w(x^i)-y_i)^2=(y-Xw)^T(y-Xw) $$\n这里涉及到矩阵求导 # 分子布局： 分子为列向量或者分母为行向量\n**分母布局：**分子为行向量或者分母为列向量 $$ \\dfrac{\\partial(y-Xw)^T(y-Xw)}{\\partial w} $$ $$ \\dfrac{\\partial(y^Ty-y^TXw-w^TX^Ty+w^TX^TXw)}{\\partial w} $$ $$ \\dfrac{\\partial y^Ty}{\\partial w}-\\dfrac{\\partial y^TXw}{\\partial w}-\\dfrac{\\partial w^TX^Ty}{\\partial w}+\\dfrac{\\partial w^TX^TXw}{\\partial w} $$ 矩阵的求导百度查表\n在这里我们查表后可以求得： $$ \\dfrac{\\partial y^Ty}{\\partial w}=0 $$ $$ \\dfrac{\\partial y^TXw}{\\partial w}=X^Ty $$ $$ \\dfrac{\\partial w^TX^Ty}{\\partial w}=\\dfrac{\\partial(w^TX^Ty)^T}{\\partial w}=\\dfrac{\\partial y^TXw}{\\partial w}=X^Ty $$ $$ \\dfrac{\\partial w^TX^TXw}{\\partial w}=2X^TXw $$ 那么： $$ \\dfrac{\\partial y^Ty}{\\partial w}-\\dfrac{\\partial y^TXw}{\\partial w}-\\dfrac{\\partial w^TX^Ty}{\\partial w}+\\dfrac{\\partial w^TX^TXw}{\\partial w}=0-X^Ty-X^Ty+2X^TXw $$ $$ -2X^Ty+2X^TXw=0 $$ $$ X^TXw=X^Ty $$ $$ (X^TX)^{-1}X^TXw=(X^TX)^{-1}X^Ty $$ $$ w=(X^TX)^{-}X^Ty $$ 矩阵不可逆的情况 1、线性相关的特征(多重共线性)。 例如:$x_1$为房子的面积,单位是平方英尺 $x_2$为房子的面积,单位是平方米 预测房价 1平方英尺$≈0.0929$平方米 2、特征数据太多(样本数m≤特征数量n )\n梯度下降法和标准方程法的优缺点对比 # 方程类型 优点 缺点 梯度下降法 当特征值非常多的时候也可以很好的工作 需要选择合适的学习率\n需要迭代很多个周期\n只能得到最优解的近似值 标准方程法 不需要学习率\n不需要迭代\n可以得到全局最优解 需要计算$(X^TX)^{-1}$\n时间复杂度大约是$O(n^3)$\nn是特征数量 实战： 标准方程法解决线性回归 import numpy as np from numpy import genfromtxt import matplotlib.pyplot as plt #----------------------------------- # 载入数据 data = np.genfromtxt(\u0026#34;data.csv\u0026#34;, delimiter=\u0026#34;,\u0026#34;) x_data = data[:,0,np.newaxis] y_data = data[:,1,np.newaxis] plt.scatter(x_data,y_data) plt.show() print(np.mat(x_data).shape) print(np.mat(y_data).shape) # 给样本添加偏置项 X_data = np.concatenate((np.ones((100,1)),x_data),axis=1) print(X_data.shape) #---------------------------------- # 标准方程法求解回归参数 def weights(xArr, yArr): xMat = np.mat(xArr) yMat = np.mat(yArr) xTx = xMat.T*xMat # 矩阵乘法 # 计算矩阵的值,如果值为0，说明该矩阵没有逆矩阵 if np.linalg.det(xTx) == 0.0: print(\u0026#34;This matrix cannot do inverse\u0026#34;) return # xTx.I为xTx的逆矩阵 ws = xTx.I*xMat.T*yMat return ws #---------------------------------- #调用上面这个函数 ws = weights(X_data,y_data) #---------------------------------- # 画图 x_test = np.array([[20],[80]]) y_test = ws[0] + x_test*ws[1] plt.plot(x_data, y_data, \u0026#39;b.\u0026#39;) plt.plot(x_test, y_test, \u0026#39;r\u0026#39;) plt.show() 三、特征缩放 # 当数据中的特征的值相差较大时将不利于我们拟合以及作图。例如$x_1=房子的面积（1000000cm^2-2000000cm^2)$ $x_2=房间的数量（1-5）$\n1、数据归一化 # 数据归一化就是把数据的取值范围处为0-1或者-1-1之间 任意数据转化为0-1之间：$newValue=(oldValue-min)/(max-min)$ 任意数据转化为-1-1之间：$newValue=((oldValue-min)/(max-min)-0.5)*2$\n2、均值标准化 # $newValue=(oldValue-u)/s$\nx为特诊数据，u为数据的平均值，s为数据的方差\n四、交叉验证法 # 当数据中的记录数量本身不是很多时，如果将数据集按原来的方式划分成训练集和测试集时，就会降低我们训练的效果。这时我们可以将数据划分成n等份（一般划分为10份）然后需要循环n次，每一次循环都取不一样的一份为测试机，剩下的全部为训练集，这样每执行一次循环都会得到一个误差值E，那么最后我们所有误差求和后在求平均值就可以得到较好的误差的值$E=\\dfrac{1}{n}\\displaystyle\\sum_{i=1}^nE_i$\n五、过拟合及正则化 # 拟合情况一般可以分为三种：欠拟合、正确拟合和过拟合。 欠拟合：就是拟合程度不够导致模型在训练集和测试集中都表现较差。 正确拟合：模型拟合程度高，在训练集和测试集里的表现都很好 过拟合：模型的拟合程度太极端，导致模型在训练集中的表现非常完美，但是在测试集中往往会出现很多误差\n防止过拟合的措施 # 1.减少特征 2.增加数据量 3.正则化\n正则化 # 正则化代价函数与普通的代价函数差不多，唯一的不同就是最后会加一项$\\lambda\\displaystyle\\sum_{j=1}^n\\theta_j^2$或则$\\lambda\\displaystyle\\sum_{j=1}^n\\vert\\theta_j\\vert$。前者叫L2正则化，后者叫L1正则化。\n六、岭回归 # 在前面标准方程法中求得的权值的表达式是：$w=(X^TX)^{-}X^Ty$。如果数据的特征比样本点还多, 数据特征n,样本个数m，如果n\u0026gt; m,则计算$(X^TX)^{-1}$时会出错。因为$(X^TX)$不是满秩矩阵，所以不可逆。\n为了解决这个问题,统计学家引入了岭回归的概念。 $$ w=(X^T+\\lambda I)^{-1}X^Ty $$ $\\lambda$为岭系数, $I$为单位矩阵(对角线.上全为1 ,其他元素全为0)\r岭回归的代价函数是之前谈到的L2正则化。\r$$\rJ(\\theta)=\\dfrac{1}{2}\\displaystyle\\sum_{i=1}^n(h_\\theta(x_i)-y_i)^2+\\lambda\\displaystyle\\sum_{i}^n\\theta_i^2\r$$\r岭回归最早是用来处理特征数多于样本的情况,现在也\r用于在估计中加入偏差,从而得到更好的估计。同时也\r可以解决多重共线性的问题。岭回归是一种有偏估计。\r**岭回归代价函数：**$J(\\theta)=\\dfrac{1}{2m}\\left[\\displaystyle\\sum_{i=1}^m(h_\\theta(x_i)-y_i)^2+\\lambda\\displaystyle\\sum_{j}^n\\theta_j^2\\right]$\r**线性回归标准方程法：**$w=(X^TX)^{-}X^Ty$\r**岭回归求解：**$w=(X^T+\\lambda I)^{-1}X^Ty$\r$\\lambda为岭系数$\r在选择$\\lambda$的值的时候，需要考查下面两个问题使得: 1.各回归系数的岭估计基本稳定。 2.残差平方和增大不太多。\n","date":"26 October 2022","permalink":"/posts/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%8F%8A%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/","section":"Posts","summary":"线性还是非线性是要根据分析的目标来决定的，在线性回归和非线性回归中，我们需要求解的是模型参数，因而，线性与非线性描述的是函数模型与模型参数之间的关系，而非因变量与自变量之间的关系\n代价函数（损失函数）（Cost function） # 最小二乘法 真实值$y$,预测值$h_\\theta$,则误差平方为$(y-h_\\theta(x))^2$. 找到合适的参数，使得误差平方和： $$ 对于线性的： h_\\theta(x)=\\theta_0+\\theta_1x J(\\theta_0,\\theta_1)=\\dfrac{1}{2m}\\textstyle\\sum_{i=1}^m(y^i-h_\\theta(x^j))^2 $$ 最小\n我们使用相关系数去衡量线性相关的强弱： $$ r_{xy}=\\dfrac{\\sum(X_i-\\overline{X})(Y_i-\\overline{Y})}{\\sqrt{\\sum(X_i-\\overline{X})^2\\sum(Y_i-\\overline{Y})^2}} $$ 其中$X_i$表示真实值的横坐标；$Y_i$表示真实值纵横坐标；$\\overline{X}$表示真实值的横坐标的平均值；$\\overline{Y}$表示真实值的纵坐标的平均值。 相关系数$R^2$是用来描述两个变量之间的线性关系的，但决定系数的适用范围更广, 可以用于描述非线性或者有个及两个以上自变量的相关关系。它可以用来评价模型的效果。 总平方和（SST）：$\\textstyle\\sum_{i=1}^n(y_i-\\overline{y})^2$ 回归平方和（SSR）：$\\textstyle\\sum_{i=1}^n(\\hat{y}-\\overline{y})^2$ 残差平方和（SSE）：$\\textstyle\\sum_{i=1}^n(y_i-\\hat{y})^2$ 它们三者的关系是：$SST=SSR+SSE$ 决定系数：$R^2=\\dfrac{SSR}{SST}=1-\\dfrac{SSE}{SST}$ 一、梯度下降 # 需要做一个迭代： $$ \\theta_j:=\\theta_j-\\alpha\\dfrac{\\partial}{\\partial\\theta_j}J(\\theta_0,\\theta_1),j=0,1 $$ 其中$\\alpha$为学习率;$:=$为赋值符，将右边赋值给左边","title":"线性回归及非线性回归"},{"content":"","date":"26 October 2022","permalink":"/tags/numpy/","section":"Tags","summary":"","title":"Numpy"},{"content":" NumPy是一个功能强大的Python库，主要用于对多维数组执行计算。NumPy这个词来源于两个单词\u0026ndash; Numerical和Python。NumPy提供了大量的库函数和操作，可以帮助程序员轻松地进行数值计算。这类数值计算广泛用于以下任务：\n机器学习模型：在编写机器学习算法时，需要对矩阵进行各种数值计算。例如矩阵乘法、换位、加法等。NumPy提供了一个非常好的库，用于简单(在编写代码方面)和快速(在速度方面)计算。NumPy数组用于存储训练数据和机器学习模型的参数。 图像处理和计算机图形学：计算机中的图像表示为多维数字数组。NumPy成为同样情况下最自然的选择。实际上，NumPy提供了一些优秀的库函数来快速处理图像。例如，镜像图像、按特定角度旋转图像等。 数学任务：NumPy对于执行各种数学任务非常有用，如数值积分、微分、内插、外推等。因此，当涉及到数学任务时，它形成了一种基于Python的MATLAB的快速替代。 一、Numpy中的数组 # import numpy as np\n函数 作用 np.array() 生成一维或多维数组 np.shape 查看数组的形状。 np.zeros((n)) 生成一个n元素的一维的全0数组 np.zeros((n,m)) 生成一个n*m维的全0数组 np.ones((n)) 生成全1的数组 np.ones((n,m)) 生成n*m的全1的数组 np.random.random((n)) 随机生成一个n元素的一维数组 (()) 凡是带两个括号的函数里面跟的都是向量。可以是多个数 np.linspace(begin,end,n步数) 这个方法是生成begin到end之间的平均步长的n个数。n就是步数 二、Numpy中数组的操作 # 多维数组切片 # # MD slicing print(a[0, 1:4]) # \u0026gt;\u0026gt;\u0026gt;[12 13 14] print(a[1:4, 0]) # \u0026gt;\u0026gt;\u0026gt;[16 21 26] print(a[::2,::2]) # \u0026gt;\u0026gt;\u0026gt;[[11 13 15] # [21 23 25] # [31 33 35]] print(a[:, 1]) # \u0026gt;\u0026gt;\u0026gt;[12 17 22 27 32] $$ \\begin{bmatrix} 11\u0026amp;12\u0026amp;13\u0026amp;14\u0026amp;15 \\\\ 16\u0026amp;17\u0026amp;18\u0026amp;19\u0026amp;20 \\\\ 21\u0026amp;22\u0026amp;23\u0026amp;24\u0026amp;25 \\\\ 26\u0026amp;27\u0026amp;28\u0026amp;29\u0026amp;30 \\\\ 31\u0026amp;32\u0026amp;33\u0026amp;34\u0026amp;35 \\end{bmatrix} $$\n数组属性 # 在使用 NumPy 时，你会想知道数组的某些信息。很幸运，在这个包里边包含了很多便捷的方法，可以给你想要的信息。\n# Array properties a = np.array([[11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25], [26, 27, 28 ,29, 30], [31, 32, 33, 34, 35]]) print(type(a)) # \u0026gt;\u0026gt;\u0026gt;\u0026lt;class \u0026#39;numpy.ndarray\u0026#39;\u0026gt; print(a.dtype) # \u0026gt;\u0026gt;\u0026gt;int64 print(a.size) # \u0026gt;\u0026gt;\u0026gt;25 print(a.shape) # \u0026gt;\u0026gt;\u0026gt;(5, 5) print(a.itemsize) # \u0026gt;\u0026gt;\u0026gt;8 print(a.ndim) # \u0026gt;\u0026gt;\u0026gt;2 print(a.nbytes) # \u0026gt;\u0026gt;\u0026gt;200 正如你在上面的代码中看到的，NumPy数组实际上被称为ndarray。我不知道为什么他妈的它叫ndarray，如果有人知道请留言！我猜它代表n维数组。\n数组的形状是它有多少行和列，上面的数组有5行和5列，所以它的形状是(5，5)。\nitemsize属性是每个项占用的字节数。这个数组的数据类型是int 64，一个int 64中有64位，一个字节中有8位，除以64除以8，你就可以得到它占用了多少字节，在本例中是8。\nndim 属性是数组的维数。这个有2个。例如，向量只有1。\nnbytes 属性是数组中的所有数据消耗掉的字节数。你应该注意到，这并不计算数组的开销，因此数组占用的实际空间将稍微大一点。\n基本操作符 # 使用NumPy，你可以轻松地在数组上执行数学运算。例如，你可以添加NumPy数组，你可以减去它们，你可以将它们相乘，甚至可以将它们分开。 以下是一些例子：\nimport numpy as np a = np.array([[1.0, 2.0], [3.0, 4.0]]) b = np.array([[5.0, 6.0], [7.0, 8.0]]) sum = a + b difference = a - b product = a * b quotient = a / b print \u0026#34;Sum = \\n\u0026#34;, sum print \u0026#34;Difference = \\n\u0026#34;, difference print \u0026#34;Product = \\n\u0026#34;, product print \u0026#34;Quotient = \\n\u0026#34;, quotient # The output will be as follows: Sum = [[ 6. 8.] [10. 12.]] Difference = [[-4. -4.] [-4. -4.]] Product = [[ 5. 12.] [21. 32.]] Quotient = [[0.2 0.33333333] [0.42857143 0.5 ]] 乘法运算符执行逐元素乘法而不是矩阵乘法。 要执行矩阵乘法，你可以执行以下操作：\nmatrix_product = a.dot(b) print \u0026#34;Matrix Product = \u0026#34;, matrix_product 矩阵a乘以矩阵b表示为a.dot(b)\n布尔屏蔽 # 布尔屏蔽是一个有用的功能，它允许我们根据我们指定的条件检索数组中的元素。\n# Boolean masking import matplotlib.pyplot as plt a = np.linspace(0, 2 * np.pi, 50) b = np.sin(a) plt.plot(a,b) mask = b \u0026gt;= 0 plt.plot(a[mask], b[mask], \u0026#39;bo\u0026#39;) mask = (b \u0026gt;= 0) \u0026amp; (a \u0026lt;= np.pi / 2) plt.plot(a[mask], b[mask], \u0026#39;go\u0026#39;) plt.show() 缺省索引 # 不完全索引是从多维数组的第一个维度获取索引或切片的一种方便方法。例如，如果数组a=[1，2，3，4，5]，[6，7，8，9，10]，那么[3]将在数组的第一个维度中给出索引为3的元素，这里是值4。\n# Incomplete Indexing a = np.arange(0, 100, 10) b = a[:5] c = a[a \u0026gt;= 50] print(b) # \u0026gt;\u0026gt;\u0026gt;[ 0 10 20 30 40] print(c) # \u0026gt;\u0026gt;\u0026gt;[50 60 70 80 90] Where函数 # where() 函数是另外一个根据条件返回数组中的值的有效方法。只需要把条件传递给它，它就会返回一个使得条件为真的元素的列表。\n# Where a = np.arange(0, 100, 10) b = np.where(a \u0026lt; 50) c = np.where(a \u0026gt;= 50)[0] print(b) # \u0026gt;\u0026gt;\u0026gt;(array([0, 1, 2, 3, 4]),) print(c) # \u0026gt;\u0026gt;\u0026gt;[5 6 7 8 9] 三、创建Numpy数组的不同方式 # 创建Numpy数组有三种不同的方法：\n使用Numpy内部功能函数 从列表等其他Python的结构进行转换 使用特殊的库函数 1、使用Numpy内部功能函数 # 创建一个一维数组 # 首先，让我们创建一维数组或rank为1的数组。arange是一种广泛使用的函数，用于快速创建数组。将值20传递给arange函数会创建一个值范围为0到19的数组。\nimport Numpy as np array = np.arange(20) array 输出\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]) 要验证此数组的维度，请使用shape属性。\narray.shape 输出：\n(20,) 由于逗号后面没有值，因此这是一维数组。 要访问此数组中的值，请指定非负索引。 与其他编程语言一样，索引从零开始。 因此，要访问数组中的第四个元素，请使用索引3。\narray[3] 输出：\n3 Numpy的数组是可变的，这意味着你可以在初始化数组后更改数组中元素的值。 使用print函数查看数组的内容。\narray[3] = 100 print(array) 输出：\n[ 0 1 2 100 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19] 与Python列表不同，Numpy数组的内容是同质的。 因此，如果你尝试将字符串值分配给数组中的元素，其数据类型为int，则会出现错误。\narray[3] =\u0026#39;Numpy\u0026#39; 输出：\nValueError: invalid literal for int() with base 10: \u0026#39;Numpy\u0026#39; 创建一个二维数组 # 我们来谈谈创建一个二维数组。 如果只使用arange函数，它将输出一维数组。 要使其成为二维数组，请使用reshape函数链接其输出。\narray = np.arange(20).reshape(4,5)\rarray 输出：\narray([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]]) 首先，将创建20个整数，然后将数组转换为具有4行和5列的二维数组。 我们来检查一下这个数组的维数。\n(4, 5) 由于我们得到两个值，这是一个二维数组。 要访问二维数组中的元素，需要为行和列指定索引。\narray[3][4] 输出：\n19 创建三维数组及更多维度 # 要创建三维数组，请为重塑形状函数指定3个参数。\narray = np.arange(27).reshape(3,3,3) array 输出：\narray([[[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8]], [[ 9, 10, 11], [12, 13, 14], [15, 16, 17]], [[18, 19, 20], [21, 22, 23], [24, 25, 26]]]) 需要注意的是：数组中元素的数量（27）必须是其尺寸（3 * 3 * 3）的乘积。 要交叉检查它是否是三维数组，可以使用shape属性。\narray.shape 输出：\n(3, 3, 3) 此外，使用arange函数，你可以创建一个在定义的起始值和结束值之间具有特定序列的数组。\nnp.arange(10, 35, 3) 输出：\narray([10, 13, 16, 19, 22, 25, 28, 31, 34]) 2、使用其他Numpy函数 # 除了arange函数之外，你还可以使用其他有用的函数（如 zeros 和 ones）来快速创建和填充数组。\n使用zeros函数创建一个填充零的数组。函数的参数表示行数和列数（或其维数）。\nnp.zeros((2,4)) 输出：\narray([[0., 0., 0., 0.],\r[0., 0., 0., 0.]]) 使用ones函数创建一个填充了1的数组。\nnp.ones((3,4)) 输出：\narray([[1., 1., 1., 1.],\r[1., 1., 1., 1.],\r[1., 1., 1., 1.]]) empty函数创建一个数组。它的初始内容是随机的，取决于内存的状态。\nnp.empty((2,3)) 输出：\narray([[0.65670626, 0.52097334, 0.99831087],\r[0.07280136, 0.4416958 , 0.06185705]]) full函数创建一个填充给定值的n * n数组。\nnp.full((2,2), 3) 输出：\narray([[3, 3],\r[3, 3]]) eye函数可以创建一个n * n矩阵，对角线为1，其他为0。\nnp.eye(3,3) 输出：\narray([[1., 0., 0.],\r[0., 1., 0.],\r[0., 0., 1.]]) 函数linspace在指定的时间间隔内返回均匀间隔的数字。 例如，下面的函数返回0到10之间的四个等间距数字。\nnp.linspace(0, 10, num=4) 输出：\narray([ 0., 3.33333333, 6.66666667, 10.]) 3、从Python列表转换 # 除了使用Numpy函数之外，你还可以直接从Python列表创建数组。将Python列表传递给数组函数以创建Numpy数组：\narray = np.array([4,5,6]) array 输出：\narray([4, 5, 6]) 你还可以创建Python列表并传递其变量名以创建Numpy数组。\nlist = [4,5,6] list 输出：\n[4, 5, 6] array = np.array(list) array 输出：\narray([4, 5, 6]) 你可以确认变量array和list分别是Python列表和Numpy数组。\ntype(list) list type(array) Numpy.ndarray 要创建二维数组，请将一系列列表传递给数组函数。\narray = np.array([(1,2,3), (4,5,6)]) array 输出：\narray([[1, 2, 3], [4, 5, 6]]) array.shape 输出：\n(2, 3) 4、使用特殊的库函数 # 你还可以使用特殊库函数来创建数组。例如，要创建一个填充0到1之间随机值的数组，请使用random函数。这对于需要随机状态才能开始的问题特别有用。\nnp.random.random((2,2)) 输出：\narray([[0.1632794 , 0.34567049], [0.03463241, 0.70687903]]) 四、Numpy中的矩阵和向量 # numpy的ndarray类用于表示矩阵和向量。 要在numpy中构造矩阵，我们在列表中列出矩阵的行， 并将该列表传递给numpy数组构造函数。\n例如，构造与矩阵对应的numpy数组 $$ \\begin{bmatrix}1\u0026amp;-1\u0026amp;2\\3\u0026amp;2\u0026amp;0\\end{bmatrix} $$ 我们会这样做\nA = np.array([[1,-1,2],[3,2,0]]) 向量只是具有单列的数组。 例如，构建向量 $$ \\begin{bmatrix}2\\1\\3\\end{bmatrix} $$ 我们会这样做\nv = np.array([[2],[1],[3]]) 更方便的方法是转置相应的行向量。 例如，为了使上面的矢量，我们可以改为转置行向量 $$ \\begin{bmatrix}2\u0026amp;1\u0026amp;3\\end{bmatrix} $$ 这个代码是\nv = np.transpose(np.array([[2,1,3]])) numpy重载数组索引和切片符号以访问矩阵的各个部分。 例如，要打印矩阵A中的右下方条目，我们会这样做\nprint(A[1,2]) 要切出A矩阵中的第二列，我们会这样做\ncol = A[:,1:2] 第一个切片选择A中的所有行，而第二个切片仅选择每行中的中间条目。\n要进行矩阵乘法或矩阵向量乘法，我们使用np.dot()方法。\nw = np.dot(A,v) 用numpy求解方程组 # 线性代数中比较常见的问题之一是求解矩阵向量方程。 这是一个例子。 我们寻找解决方程的向量x\n\\(Ax = b\\)\n当\n$$ A=\\begin{bmatrix} 2\u0026amp;1\u0026amp;-2 \\\\ 3\u0026amp;0\u0026amp;1 \\\\ 1\u0026amp;1\u0026amp;-1 \\end{bmatrix} \\\\ b=\\begin{bmatrix}-3\\\\5\\\\-2\\end{bmatrix} $$\n我们首先构建A和b的数组。\nA = np.array([[2,1,-2],[3,0,1],[1,1,-1]]) b = np.transpose(np.array([[-3,5,-2]])) 为了解决A矩阵除以b向量\nx = np.linalg.solve(A,b) Numpy总结 # 首先，python中的普通数组的类型是list，而Numpy中的数组（一维叫向量，二维叫矩阵）的类型都是numpy.ndarray\n方法 解释 np.array(list) 将list数组创建成numpy中的矩阵即ndarray np.arange(n) 创建一个一维的从0到n-1的ndarray数组 array.shape(数组变量名.shape) 查看数组的维度，几乘几 array.ndim(数组变量名.ndim) 查看数组的维度，只显示几维 array.sum(数组变量名.sum) 求和 array.max(数组变量名.max) 求最大值 array.min(数组变量名.min) 求最小值 numpy中数组元素的访问与赋值 跟普通数组一样，通过下标访问，从0开始。可直接通过=赋值 numpy可以存任意数据么 与普通数组不同，numpy只能存同类型的数据。 np.arange(n),reshape(x,y) 将np.arange(n)这个一维数组转化成x*y的二维矩阵。x*y必须等于n。reshape中的参数可以很多维，但是乘积必须等于n np.zeros((n,m)) 生成n*m的全0矩阵 np.ones((n,m)) 生成n*m的全1矩阵 np.eye((n,m)) 生成n*m的单位矩阵 np.empty((n,m)) 随机生成一个n*m的矩阵，与内存状态有关，不可控 np.full((n,m),k) 生成一个全是k的n*m的矩阵 np.linspace(begin,end,num) 将begin到end分成num份，然后生成一个一维数组。闭区间 np.dot(a,b) 矩阵a乘以矩阵b，遵循高代 np.transpose(a) 转置矩阵a np.linalg.solve(a,b) 矩阵a除以矩阵b，遵循高代 ","date":"26 October 2022","permalink":"/posts/numpy%E7%9A%84%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/","section":"Posts","summary":"NumPy是一个功能强大的Python库，主要用于对多维数组执行计算。NumPy这个词来源于两个单词\u0026ndash; Numerical和Python。NumPy提供了大量的库函数和操作，可以帮助程序员轻松地进行数值计算。这类数值计算广泛用于以下任务：\n机器学习模型：在编写机器学习算法时，需要对矩阵进行各种数值计算。例如矩阵乘法、换位、加法等。NumPy提供了一个非常好的库，用于简单(在编写代码方面)和快速(在速度方面)计算。NumPy数组用于存储训练数据和机器学习模型的参数。 图像处理和计算机图形学：计算机中的图像表示为多维数字数组。NumPy成为同样情况下最自然的选择。实际上，NumPy提供了一些优秀的库函数来快速处理图像。例如，镜像图像、按特定角度旋转图像等。 数学任务：NumPy对于执行各种数学任务非常有用，如数值积分、微分、内插、外推等。因此，当涉及到数学任务时，它形成了一种基于Python的MATLAB的快速替代。 一、Numpy中的数组 # import numpy as np\n函数 作用 np.array() 生成一维或多维数组 np.shape 查看数组的形状。 np.zeros((n)) 生成一个n元素的一维的全0数组 np.zeros((n,m)) 生成一个n*m维的全0数组 np.ones((n)) 生成全1的数组 np.ones((n,m)) 生成n*m的全1的数组 np.random.random((n)) 随机生成一个n元素的一维数组 (()) 凡是带两个括号的函数里面跟的都是向量。可以是多个数 np.","title":"Numpy的简单入门"},{"content":"","date":"25 October 2022","permalink":"/tags/blowfish/","section":"Tags","summary":"","title":"Blowfish"},{"content":"","date":"25 October 2022","permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo"},{"content":"","date":"25 October 2022","permalink":"/tags/markdown/","section":"Tags","summary":"","title":"Markdown"},{"content":"","date":"25 October 2022","permalink":"/categories/%E5%8D%9A%E5%AE%A2/","section":"Categories","summary":"","title":"博客"},{"content":"Hugo是Go编写的静态网站生成器，速度快,易用，可配置。Hugo 有一个内容和模板目录，把他们渲染到完全的HTML网站。Hugo非常适合博客，文档等等网站的生成。Hugo依赖于Markdown文件，元数据字体。用户可以从任意的目录中运行 Hugo，支持共享主机和其他系统。\n一、安装Hugo（windows） # Github下载Hugo的发行版 https://github.com/gohugoio/hugo/releases 本人推荐下载extended版的 将下载好的zip文件解压到你想存放的hugo的安装目录。解压后的文件夹中有三个文件，其中有一个是exe可执行文件。不要执行它，这不是安装程序。把它的路径配置到环境变量中 配置好环境变量后到命令行窗口输入hugo version查看是否安装成功 现在你可以通过hugo new site YourBlogProjectName命令来创建一个新的站点了 创建好站点后在当前界面执行cd命令进入到你的站点文件夹下，然后执行hugo server命令就可以开启这个站点了。此时访问http://localhost:1313/ 就是你站点的地址，由于是一个全新的站点此时访问是没有任何东西的。 至此，你的hugo以及站点就安装配置完成，下一步就是为你的站点选一个好看的主题，如果你对Blowfish这个主题感兴趣那就继续往下看吧 二、安装Blowfish # 主题地址： https://themes.gohugo.io/themes/blowfish/ Blowfish的作者提供了三种使用该主题的方式，但是我本人比较喜欢作者提供的Hugo Module的方式，以下对该方式展开讲解。\n作者提供的安装文档查看：https://nunocoracao.github.io/blowfish/docs/installation/#install-using-hugo\n1、模块初始化。上面我们已经创建了一个hugo项目myBlog，现在我们要基于它做一个初始化。以下步骤建议到VS Code中进行。在VS Code中导入myBlog项目后执行hugo mod init myBlog。此时你会看到左边资源管理器会多出来一个go.mod文件 2、在myBlog项目中按如下路径新建配置文件config/_default/module.toml。没有文件夹需要先创建。你也可以访问这个地址去下载副本（建议）因为这里有所有会涉及到的配置文件，会简化你后面所有的操作： https://minhaskamal.github.io/DownGit/#/home?url=https:%2F%2Fgithub.com%2Fnunocoracao%2Fblowfish%2Ftree%2Fmain%2Fconfig%2F_default 你将得到这样一个文件结构 config/_default/\r├─ config.toml\r├─ markup.toml\r├─ menus.toml\r├─ module.toml\r└─ params.toml 现在到module.toml中删除里面原先的所有内容，然后复制下面的内容到里面去： [[imports]]\rpath = \u0026#34;github.com/nunocoracao/blowfish/v2\u0026#34; 然后执行hugo server命令启动服务器，主题将自动下载 等待命令执行完，项目启动后即可访问 这便是主题的下载与安装。下面演示如何进行主题配置 三、配置主题 # 1、中文 # 到config\\_default\\config.toml下设置defaultContentLanguage = \u0026quot;zh-cn\u0026quot; 再到config_default下创建名为languages.zh-cn.toml的配置文件，可以复制languages.en.toml的来修改 在languages.zh-cn.toml中去修改你这个网站对应的中文的一些信息 2、菜单 # 如果你启用的中文，需要到config_default下新建一个名为menus.zh-cn.toml的配置文件，同样你可以直接复制menus.en.toml`的来修改 [[main]]和[[footer]]两种标签，分别表示右上角和左下角的菜单项。name为该标签在页面上显示的名称 pageRef为该标签访问的路由。 3、替换网页标签图标 # 网页标签图标通常是由\u0026lt;head\u0026gt;\u0026lt;/head\u0026gt;中的\u0026lt;link\u0026gt;来设置，在这里我们需要新建一个html文件，在里面设置link标签来替换原生的link 到layouts文件夹下新建\\partials\\favicons.html目录与文件 到favicons.html文件中设置\u0026lt;link rel=\u0026quot;icon\u0026quot; type=\u0026quot;image/jpg\u0026quot; href=\u0026quot;./favicon_hp.jpg\u0026quot; sizes=\u0026quot;16x16\u0026quot;\u0026gt; 图标文件需要存放到static目录中 4、其他更多参数配置 # 更多的参数配置参考主题详细文档： https://nunocoracao.github.io/blowfish/docs/configuration/ 四、发布文章 # 假如你菜单配置的Posts指向的是posts，那么你需要在content文件夹下再创建一个posts文件夹。 每个文章还需要创建单独的文件夹，用来存放markdown文件和图片等静态资源，加入你开启了文章缩略图，那么每个文章的markdown文件命名就都得是index.md而对应的缩略图呢就得在同一目录下命名为featured.png或featured.jpg。像这样： content\r└── posts\r└──awesome_article\r├── index.md\r└── featured.png 头部格式： ---\rtitle: \u0026#34;标题\u0026#34;\rdescription: 描述\rdate: 2022-10-25T21:25:00+08:00\rdraft: false\rcategories:\r- 分类\rtags:\r- 标签1\r- 标签2\r- 标签3\r--- date: 2022-10-25T21:25:00+08:00时间格式不要搞错\n","date":"25 October 2022","permalink":"/posts/hi/","section":"Posts","summary":"Hugo是Go编写的静态网站生成器，速度快,易用，可配置。Hugo 有一个内容和模板目录，把他们渲染到完全的HTML网站。Hugo非常适合博客，文档等等网站的生成。Hugo依赖于Markdown文件，元数据字体。用户可以从任意的目录中运行 Hugo，支持共享主机和其他系统。\n一、安装Hugo（windows） # Github下载Hugo的发行版 https://github.com/gohugoio/hugo/releases 本人推荐下载extended版的 将下载好的zip文件解压到你想存放的hugo的安装目录。解压后的文件夹中有三个文件，其中有一个是exe可执行文件。不要执行它，这不是安装程序。把它的路径配置到环境变量中 配置好环境变量后到命令行窗口输入hugo version查看是否安装成功 现在你可以通过hugo new site YourBlogProjectName命令来创建一个新的站点了 创建好站点后在当前界面执行cd命令进入到你的站点文件夹下，然后执行hugo server命令就可以开启这个站点了。此时访问http://localhost:1313/ 就是你站点的地址，由于是一个全新的站点此时访问是没有任何东西的。 至此，你的hugo以及站点就安装配置完成，下一步就是为你的站点选一个好看的主题，如果你对Blowfish这个主题感兴趣那就继续往下看吧 二、安装Blowfish # 主题地址： https://themes.gohugo.io/themes/blowfish/ Blowfish的作者提供了三种使用该主题的方式，但是我本人比较喜欢作者提供的Hugo Module的方式，以下对该方式展开讲解。\n作者提供的安装文档查看：https://nunocoracao.github.io/blowfish/docs/installation/#install-using-hugo\n1、模块初始化。上面我们已经创建了一个hugo项目myBlog，现在我们要基于它做一个初始化。以下步骤建议到VS Code中进行。在VS Code中导入myBlog项目后执行hugo mod init myBlog。此时你会看到左边资源管理器会多出来一个go.","title":"如何使用Hugo引用Blowfish主题创建一个唯美的博客"}]